# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/conv.ipynb.

# %% auto 0
__all__ = ['device', 'conv', 'to_device', 'collate_']

# %% ../nbs/conv.ipynb 1
import torch
from torch import nn

from torch.utils.data import default_collate
from typing import Mapping
from .core import *
from .training import *

# %% ../nbs/conv.ipynb 3
import math,numpy as np,matplotlib.pyplot as plt
from operator import itemgetter
from itertools import zip_longest
import fastcore.all as fc

from torch.utils.data import default_collate

#from miniai.training import *
#!pip install miniai
import logging,pickle,gzip,os,time,shutil,torch,matplotlib as mpl
from pathlib import Path

from torch import tensor,nn,optim
from torch.utils.data import DataLoader
import torch.nn.functional as F
from datasets import load_dataset,load_dataset_builder

import torchvision.transforms.functional as TF
from fastcore.test import test_close

# %% ../nbs/conv.ipynb 10
def conv(ni,nf,ks=3,stride=2,act=True):
    con = nn.Conv2d(ni,nf,kernel_size = ks,padding = ks//2,stride = stride)
    if act: con = nn.Sequential(con,nn.ReLU())
    return con

# %% ../nbs/conv.ipynb 19
device = 'cuda'
def to_device(x,device=device):
    if isinstance(x,torch.Tensor): return x.to(device)
    if isinstance(x,dict): return {k:v.to(device) for k,v in x.items()}
    if isinstance(x,tuple):return (x[0].to(device),x[1].to(device))
   
    
    
    

# %% ../nbs/conv.ipynb 21
def collate_(b):   
    get = itemgetter(*train.features)
    def _f(b): return get(to_device(default_collate(b)))
    return _f
